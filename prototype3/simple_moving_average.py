# -*- coding: utf-8 -*-
"""simple moving Average

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19NZPLe8z6Nq1nXUQ2abexo5a4eZYJuCD
"""

from google.colab import drive
drive.mount('/content/drive')

import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler
import pandas as pd
import numpy as np


url = '/content/drive/MyDrive/content/NLICx.csv'
df = pd.read_csv(url)
df = df.applymap(lambda x: str(x).replace(',', ''))

import pandas as pd
import matplotlib.pyplot as plt

# Load data from CSV file
file_path = url  # Replace with your CSV file path
data = pd.read_csv(file_path)
data = data.applymap(lambda x: str(x).replace(',', ''))

# Convert 'Date' column to datetime
data['Date'] = pd.to_datetime(data['Date'])

# Convert 'Open' column to numeric (assuming it contains numbers)
data['Open'] = pd.to_numeric(data['Open'], errors='coerce')

# Drop rows with missing values
data = data.dropna(subset=['Open'])

# Calculate Simple Moving Average (SMA)
window_size = 10
data['SMA'] = data['Open'].rolling(window=window_size).mean()

# Plot the data and SMA
plt.figure(figsize=(12, 6))
plt.plot(data['Date'], data['Open'], label='Actual Price', color='blue')
plt.plot(data['Date'], data['SMA'], label=f'{window_size}-Day SMA', color='orange')
plt.title('Stock Price and Moving Average')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

# Print the last few rows of the DataFrame
print(data.tail())

# Print the predicted price for the next day based on the last value of the SMA
last_sma_value = data['SMA'].iloc[-1]
predicted_price = last_sma_value  # You can modify this based on your prediction logic
print(f"Predicted Price for the Next Day: {predicted_price}")

import pandas as pd
import matplotlib.pyplot as plt

# Load data from CSV file
file_path = url  # Replace with your CSV file path
data = pd.read_csv(file_path)
data = data.applymap(lambda x: str(x).replace(',', ''))

# Convert 'Date' column to datetime
data['Date'] = pd.to_datetime(data['Date'])

# Convert 'Open' column to numeric (assuming it contains numbers)
data['High'] = pd.to_numeric(data['High'], errors='coerce')

# Drop rows with missing values
data = data.dropna(subset=['High'])

# Calculate Simple Moving Average (SMA)
window_size = 10
data['SMA'] = data['High'].rolling(window=window_size).mean()

# Plot the data and SMA
plt.figure(figsize=(12, 6))
plt.plot(data['Date'], data['High'], label='Actual Price', color='blue')
plt.plot(data['Date'], data['SMA'], label=f'{window_size}-Day SMA', color='orange')
plt.title('Stock Price and Moving Average')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

# Print the last few rows of the DataFrame
print(data.tail())

# Print the predicted price for the next day based on the last value of the SMA
last_sma_value = data['SMA'].iloc[-1]
predicted_price = last_sma_value  # You can modify this based on your prediction logic
print(f"Predicted Price for the Next Day: {predicted_price}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# # Assuming 'your_data.csv' is the name of your CSV file
# df = pd.read_csv(url)
# df = df.applymap(lambda x: str(x).replace(',', ''))


# # Assuming 'Date' is the column containing your date information
# # You may need to parse dates if they are not in datetime format
# df['Date'] = pd.to_datetime(df['Date'])
# df.set_index('Date', inplace=True)

# # Assuming your target variable is 'Open' for this example
# target_feature = 'Open'
# df['Open'] = pd.to_numeric(df['Open'], errors='coerce')

# # Splitting the data into training and testing sets
# train_size = int(len(df) * 0.8)
# train, test = df[target_feature][:train_size], df[target_feature][train_size:]

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Assuming 'your_data.csv' is the name of your CSV file
df = pd.read_csv(url)
df = df.applymap(lambda x: str(x).replace(',', ''))

# Assuming 'Date' is the column containing your date information
# You may need to parse dates if they are not in datetime format
df['Date'] = pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)

# Assuming your target variable is 'Open' for this example
target_feature = 'Ltp'
df['Ltp'] = pd.to_numeric(df['Ltp'], errors='coerce')

# Remove outliers using IQR
def remove_outliers_iqr(data, feature):
    Q1 = data[feature].quantile(0.25)
    Q3 = data[feature].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    data_no_outliers = data[(data[feature] >= lower_bound) & (data[feature] <= upper_bound)]
    return data_no_outliers

df_no_outliers = remove_outliers_iqr(df, target_feature)

# Splitting the data into training and testing sets
train_size = int(len(df_no_outliers) * 0.8)
train, test = df_no_outliers[target_feature][:train_size], df_no_outliers[target_feature][train_size:]


# Function to difference the series
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Differencing the training data
diff_train = difference(train)

# Function to fit an AR component
def fit_ar_model(train, order):
    coef = [0.0] * (order + 1)
    for i in range(1, order + 1):
        coef[i] = np.corrcoef(train[i:], train[:-i])[0, 1]
    return np.array(coef[1:])

# Function to make predictions with AR component
def predict_ar_model(history, coefficients):
    yhat = 0.0
    for i in range(1, len(coefficients) + 1):
        yhat += coefficients[i - 1] * history[-i]
    return yhat

# Fitting AR component
order_ar = 5  # You may need to adjust this order based on your data
coef_ar = fit_ar_model(diff_train, order_ar)

# Function to fit an MA component
def fit_ma_model(train, lag):
    X = np.array([train[i:i + lag] for i in range(len(train) - lag)])
    y = train[lag:]
    coef = np.linalg.lstsq(X, y, rcond=None)[0]
    return coef

# Function to make predictions with MA component
def predict_ma_model(history, coefficients):
    return np.dot(history[-len(coefficients):], coefficients)

# Fitting MA component
order_ma = 10  # You may need to adjust this order based on your data
coef_ma = fit_ma_model(diff_train, order_ma)

# Function to invert differencing
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# Forecasting
history = list(train)
forecast = list()
for i in range(len(test)):
    # Making predictions
    yhat_ar = predict_ar_model(history, coef_ar)
    yhat_ma = predict_ma_model(history, coef_ma)
    yhat = inverse_difference(history, yhat_ar + yhat_ma, 1)

    # Appending the forecasted value to the results
    forecast.append(yhat)

    # Updating the history for the next iteration
    history.append(test[i])

final_predicted_value = forecast[-1]
print(f'Final Predicted Value: {final_predicted_value}')

# Plotting the results
plt.plot(train, label='Training Data')
plt.plot(test.index, test.values, label='Actual Data')
plt.plot(test.index, forecast, label='Forecast')
plt.legend()
plt.show()